[{"instance_id": "matplotlib__matplotlib-24362", "model_name_or_path": "claude-2", "full_output": " Here is the patch file to fix the issue:\n\n```patch\ndiff --git a/lib/matplotlib/gridspec.py b/lib/matplotlib/gridspec.py\nindex 06dd3f19f6..32ee7c306e 100644\n--- a/lib/matplotlib/gridspec.py\n+++ b/lib/matplotlib/gridspec.py\n@@ -276,9 +276,9 @@ class GridSpecBase:\n             raise ValueError(\"GridSpec.subplots() only works for GridSpecs \"\n                              \"created with a parent figure\")\n \n-        if isinstance(sharex, bool):\n+        if isinstance(sharex, bool) or sharex == 1 or sharex == 0:\n             sharex = \"all\" if sharex else \"none\"\n-        if isinstance(sharey, bool):\n+        if isinstance(sharey, bool) or sharey == 1 or sharey == 0:\n             sharey = \"all\" if sharey else \"none\"\n         # This check was added because it is very easy to type\n         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n```\n\nThis fixes the issue by checking if `sharex` and `sharey` are `1` or `0` and treating them as `True` or `False` respectively, before converting them to strings for `\"all\"` or `\"none\"`.\n\nLet me know if you would like me to modify the patch in any way.", "model_patch": "diff --git a/lib/matplotlib/gridspec.py b/lib/matplotlib/gridspec.py\nindex 06dd3f19f6..32ee7c306e 100644\n--- a/lib/matplotlib/gridspec.py\n+++ b/lib/matplotlib/gridspec.py\n@@ -276,9 +276,9 @@ class GridSpecBase:\n             raise ValueError(\"GridSpec.subplots() only works for GridSpecs \"\n                              \"created with a parent figure\")\n \n-        if isinstance(sharex, bool):\n+        if isinstance(sharex, bool) or sharex == 1 or sharex == 0:\n             sharex = \"all\" if sharex else \"none\"\n-        if isinstance(sharey, bool):\n+        if isinstance(sharey, bool) or sharey == 1 or sharey == 0:\n             sharey = \"all\" if sharey else \"none\"\n         # This check was added because it is very easy to type\n         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n", "text": "\n\nHuman: You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\n[Bug]: sharex and sharey don't accept 0 and 1 as bool values\n### Bug summary\r\n\r\nWhen using `0` or `1` in place of `False` or `True` in `sharex` or `sharex` arguments of `pyplot.subplots` an error is raised.\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\n\r\nfig, ax = plt.subplots(ncols=2,sharey=1)\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\nWe get the following error : \r\n```\r\nTraceback (most recent call last):\r\n  File \"/***/shareyArg.py\", line 3, in <module>\r\n    fig, ax = plt.subplots(ncols=2,sharey=1)\r\n  File \"/***/matplotlib/lib/matplotlib/pyplot.py\", line 1448, in subplots\r\n    axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\r\n  File \"/***/matplotlib/lib/matplotlib/figure.py\", line 889, in subplots\r\n    axs = gs.subplots(sharex=sharex, sharey=sharey, squeeze=squeeze,\r\n  File \"/***/matplotlib/lib/matplotlib/gridspec.py\", line 293, in subplots\r\n    _api.check_in_list([\"all\", \"row\", \"col\", \"none\"],\r\n  File \"/***/matplotlib/lib/matplotlib/_api/__init__.py\", line 131, in check_in_list\r\n    raise ValueError(msg)\r\nValueError: 1 is not a valid value for sharey; supported values are 'all', 'row', 'col', 'none'\r\n```\r\n\r\nNote that using `sharex` instead of `sharey` produces the same error (albeit with the following warning :\r\n```\r\nUserWarning: sharex argument to subplots() was an integer.  Did you intend to use subplot() (without 's')?\r\n```\r\nbut this is expected and not part of the present issue)\r\n\r\n### Expected outcome\r\n\r\nI expected values 1 and 0 to be understood as bool.\r\n\r\n\r\n\r\n### Additional information\r\n\r\nSuggested fix : \r\n\r\n```patch\r\ndiff --git a/lib/matplotlib/gridspec.py b/lib/matplotlib/gridspec.py\r\nindex 06dd3f19f6..32ee7c306e 100644\r\n--- a/lib/matplotlib/gridspec.py\r\n+++ b/lib/matplotlib/gridspec.py\r\n@@ -276,9 +276,9 @@ class GridSpecBase:\r\n             raise ValueError(\"GridSpec.subplots() only works for GridSpecs \"\r\n                              \"created with a parent figure\")\r\n \r\n-        if isinstance(sharex, bool):\r\n+        if isinstance(sharex, bool) or sharex == 1 or sharex == 0:\r\n             sharex = \"all\" if sharex else \"none\"\r\n-        if isinstance(sharey, bool):\r\n+        if isinstance(sharey, bool) or sharey == 1 or sharey == 0:\r\n             sharey = \"all\" if sharey else \"none\"\r\n         # This check was added because it is very easy to type\r\n         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\r\n```\r\n\r\nMaybe not accepting 1 or 0 was done on purpose, but I did not find it very clear from the error message as `True` and `False` are accepted but not listed. \r\n\r\nI am happy to chat about an other fix, if this one doesn't do the trick. I can also create a PR in case you think this fix is good enough !\r\n\r\n### Operating system\r\n\r\nLinux 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2\r\n\r\n### Matplotlib Version\r\n\r\n3.7.0.dev600+g0b6d3703ff\r\n\r\n### Matplotlib Backend\r\n\r\nTkAgg\r\n\r\n### Python version\r\n\r\n3.10.0\r\n\r\n### Jupyter version\r\n\r\nNot applicable\r\n\r\n### Installation\r\n\r\ngit checkout\n\n</issue>\n<code>\n[start of README.md]\n1 [![PyPi](https://badge.fury.io/py/matplotlib.svg)](https://badge.fury.io/py/matplotlib)\n2 [![Downloads](https://pepy.tech/badge/matplotlib/month)](https://pepy.tech/project/matplotlib)\n3 [![NUMFocus](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org)\n4 \n5 [![DiscourseBadge](https://img.shields.io/badge/help_forum-discourse-blue.svg)](https://discourse.matplotlib.org)\n6 [![Gitter](https://badges.gitter.im/matplotlib/matplotlib.svg)](https://gitter.im/matplotlib/matplotlib)\n7 [![GitHubIssues](https://img.shields.io/badge/issue_tracking-github-blue.svg)](https://github.com/matplotlib/matplotlib/issues)\n8 [![GitTutorial](https://img.shields.io/badge/PR-Welcome-%23FF8300.svg?)](https://git-scm.com/book/en/v2/GitHub-Contributing-to-a-Project)\n9 \n10 [![GitHubActions](https://github.com/matplotlib/matplotlib/workflows/Tests/badge.svg)](https://github.com/matplotlib/matplotlib/actions?query=workflow%3ATests)\n11 [![AzurePipelines](https://dev.azure.com/matplotlib/matplotlib/_apis/build/status/matplotlib.matplotlib?branchName=main)](https://dev.azure.com/matplotlib/matplotlib/_build/latest?definitionId=1&branchName=main)\n12 [![AppVeyor](https://ci.appveyor.com/api/projects/status/github/matplotlib/matplotlib?branch=main&svg=true)](https://ci.appveyor.com/project/matplotlib/matplotlib)\n13 [![Codecov](https://codecov.io/github/matplotlib/matplotlib/badge.svg?branch=main&service=github)](https://codecov.io/github/matplotlib/matplotlib?branch=main)\n14 [![LGTM](https://img.shields.io/lgtm/grade/python/github/matplotlib/matplotlib.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/matplotlib/matplotlib)\n15 \n16 ![image](https://matplotlib.org/_static/logo2.svg)\n17 \n18 Matplotlib is a comprehensive library for creating static, animated, and\n19 interactive visualizations in Python.\n20 \n21 Check out our [home page](https://matplotlib.org/) for more information.\n22 \n23 ![image](https://matplotlib.org/_static/readme_preview.png)\n24 \n25 Matplotlib produces publication-quality figures in a variety of hardcopy\n26 formats and interactive environments across platforms. Matplotlib can be\n27 used in Python scripts, Python/IPython shells, web application servers,\n28 and various graphical user interface toolkits.\n29 \n30 ## Install\n31 \n32 See the [install\n33 documentation](https://matplotlib.org/stable/users/installing/index.html),\n34 which is generated from `/doc/users/installing/index.rst`\n35 \n36 ## Contribute\n37 \n38 You've discovered a bug or something else you want to change -\n39 excellent!\n40 \n41 You've worked out a way to fix it -- even better!\n42 \n43 You want to tell us about it -- best of all!\n44 \n45 Start at the [contributing\n46 guide](https://matplotlib.org/devdocs/devel/contributing.html)!\n47 \n48 ## Contact\n49 \n50 [Discourse](https://discourse.matplotlib.org/) is the discussion forum\n51 for general questions and discussions and our recommended starting\n52 point.\n53 \n54 Our active mailing lists (which are mirrored on Discourse) are:\n55 \n56 -   [Users](https://mail.python.org/mailman/listinfo/matplotlib-users)\n57     mailing list: <matplotlib-users@python.org>\n58 -   [Announcement](https://mail.python.org/mailman/listinfo/matplotlib-announce)\n59     mailing list: <matplotlib-announce@python.org>\n60 -   [Development](https://mail.python.org/mailman/listinfo/matplotlib-devel)\n61     mailing list: <matplotlib-devel@python.org>\n62 \n63 [Gitter](https://gitter.im/matplotlib/matplotlib) is for coordinating\n64 development and asking questions directly related to contributing to\n65 matplotlib.\n66 \n67 ## Citing Matplotlib\n68 \n69 If Matplotlib contributes to a project that leads to publication, please\n70 acknowledge this by citing Matplotlib.\n71 \n72 [A ready-made citation\n73 entry](https://matplotlib.org/stable/users/project/citing.html) is\n74 available.\n75 \n76 ### Research notice\n77 \n78 Please note that this repository is participating in a study into\n79 sustainability of open source projects. Data will be gathered about this\n80 repository for approximately the next 12 months, starting from June\n81 2021.\n82 \n83 Data collected will include number of contributors, number of PRs, time\n84 taken to close/merge these PRs, and issues closed.\n85 \n86 For more information, please visit [the informational\n87 page](https://sustainable-open-science-and-software.github.io/) or\n88 download the [participant information\n89 sheet](https://sustainable-open-science-and-software.github.io/assets/PIS_sustainable_software.pdf).\n90 \n[end of README.md]\n[start of lib/matplotlib/gridspec.py]\n1 r\"\"\"\n2 :mod:`~matplotlib.gridspec` contains classes that help to layout multiple\n3 `~.axes.Axes` in a grid-like pattern within a figure.\n4 \n5 The `GridSpec` specifies the overall grid structure. Individual cells within\n6 the grid are referenced by `SubplotSpec`\\s.\n7 \n8 Often, users need not access this module directly, and can use higher-level\n9 methods like `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` and\n10 `~.Figure.subfigures`. See the tutorial\n11 :doc:`/tutorials/intermediate/arranging_axes` for a guide.\n12 \"\"\"\n13 \n14 import copy\n15 import logging\n16 from numbers import Integral\n17 \n18 import numpy as np\n19 \n20 import matplotlib as mpl\n21 from matplotlib import _api, _pylab_helpers, _tight_layout\n22 from matplotlib.transforms import Bbox\n23 \n24 _log = logging.getLogger(__name__)\n25 \n26 \n27 class GridSpecBase:\n28     \"\"\"\n29     A base class of GridSpec that specifies the geometry of the grid\n30     that a subplot will be placed.\n31     \"\"\"\n32 \n33     def __init__(self, nrows, ncols, height_ratios=None, width_ratios=None):\n34         \"\"\"\n35         Parameters\n36         ----------\n37         nrows, ncols : int\n38             The number of rows and columns of the grid.\n39         width_ratios : array-like of length *ncols*, optional\n40             Defines the relative widths of the columns. Each column gets a\n41             relative width of ``width_ratios[i] / sum(width_ratios)``.\n42             If not given, all columns will have the same width.\n43         height_ratios : array-like of length *nrows*, optional\n44             Defines the relative heights of the rows. Each row gets a\n45             relative height of ``height_ratios[i] / sum(height_ratios)``.\n46             If not given, all rows will have the same height.\n47         \"\"\"\n48         if not isinstance(nrows, Integral) or nrows <= 0:\n49             raise ValueError(\n50                 f\"Number of rows must be a positive integer, not {nrows!r}\")\n51         if not isinstance(ncols, Integral) or ncols <= 0:\n52             raise ValueError(\n53                 f\"Number of columns must be a positive integer, not {ncols!r}\")\n54         self._nrows, self._ncols = nrows, ncols\n55         self.set_height_ratios(height_ratios)\n56         self.set_width_ratios(width_ratios)\n57 \n58     def __repr__(self):\n59         height_arg = (', height_ratios=%r' % (self._row_height_ratios,)\n60                       if len(set(self._row_height_ratios)) != 1 else '')\n61         width_arg = (', width_ratios=%r' % (self._col_width_ratios,)\n62                      if len(set(self._col_width_ratios)) != 1 else '')\n63         return '{clsname}({nrows}, {ncols}{optionals})'.format(\n64             clsname=self.__class__.__name__,\n65             nrows=self._nrows,\n66             ncols=self._ncols,\n67             optionals=height_arg + width_arg,\n68             )\n69 \n70     nrows = property(lambda self: self._nrows,\n71                      doc=\"The number of rows in the grid.\")\n72     ncols = property(lambda self: self._ncols,\n73                      doc=\"The number of columns in the grid.\")\n74 \n75     def get_geometry(self):\n76         \"\"\"\n77         Return a tuple containing the number of rows and columns in the grid.\n78         \"\"\"\n79         return self._nrows, self._ncols\n80 \n81     def get_subplot_params(self, figure=None):\n82         # Must be implemented in subclasses\n83         pass\n84 \n85     def new_subplotspec(self, loc, rowspan=1, colspan=1):\n86         \"\"\"\n87         Create and return a `.SubplotSpec` instance.\n88 \n89         Parameters\n90         ----------\n91         loc : (int, int)\n92             The position of the subplot in the grid as\n93             ``(row_index, column_index)``.\n94         rowspan, colspan : int, default: 1\n95             The number of rows and columns the subplot should span in the grid.\n96         \"\"\"\n97         loc1, loc2 = loc\n98         subplotspec = self[loc1:loc1+rowspan, loc2:loc2+colspan]\n99         return subplotspec\n100 \n101     def set_width_ratios(self, width_ratios):\n102         \"\"\"\n103         Set the relative widths of the columns.\n104 \n105         *width_ratios* must be of length *ncols*. Each column gets a relative\n106         width of ``width_ratios[i] / sum(width_ratios)``.\n107         \"\"\"\n108         if width_ratios is None:\n109             width_ratios = [1] * self._ncols\n110         elif len(width_ratios) != self._ncols:\n111             raise ValueError('Expected the given number of width ratios to '\n112                              'match the number of columns of the grid')\n113         self._col_width_ratios = width_ratios\n114 \n115     def get_width_ratios(self):\n116         \"\"\"\n117         Return the width ratios.\n118 \n119         This is *None* if no width ratios have been set explicitly.\n120         \"\"\"\n121         return self._col_width_ratios\n122 \n123     def set_height_ratios(self, height_ratios):\n124         \"\"\"\n125         Set the relative heights of the rows.\n126 \n127         *height_ratios* must be of length *nrows*. Each row gets a relative\n128         height of ``height_ratios[i] / sum(height_ratios)``.\n129         \"\"\"\n130         if height_ratios is None:\n131             height_ratios = [1] * self._nrows\n132         elif len(height_ratios) != self._nrows:\n133             raise ValueError('Expected the given number of height ratios to '\n134                              'match the number of rows of the grid')\n135         self._row_height_ratios = height_ratios\n136 \n137     def get_height_ratios(self):\n138         \"\"\"\n139         Return the height ratios.\n140 \n141         This is *None* if no height ratios have been set explicitly.\n142         \"\"\"\n143         return self._row_height_ratios\n144 \n145     @_api.delete_parameter(\"3.7\", \"raw\")\n146     def get_grid_positions(self, fig, raw=False):\n147         \"\"\"\n148         Return the positions of the grid cells in figure coordinates.\n149 \n150         Parameters\n151         ----------\n152         fig : `~matplotlib.figure.Figure`\n153             The figure the grid should be applied to. The subplot parameters\n154             (margins and spacing between subplots) are taken from *fig*.\n155         raw : bool, default: False\n156             If *True*, the subplot parameters of the figure are not taken\n157             into account. The grid spans the range [0, 1] in both directions\n158             without margins and there is no space between grid cells. This is\n159             used for constrained_layout.\n160 \n161         Returns\n162         -------\n163         bottoms, tops, lefts, rights : array\n164             The bottom, top, left, right positions of the grid cells in\n165             figure coordinates.\n166         \"\"\"\n167         nrows, ncols = self.get_geometry()\n168 \n169         if raw:\n170             left = 0.\n171             right = 1.\n172             bottom = 0.\n173             top = 1.\n174             wspace = 0.\n175             hspace = 0.\n176         else:\n177             subplot_params = self.get_subplot_params(fig)\n178             left = subplot_params.left\n179             right = subplot_params.right\n180             bottom = subplot_params.bottom\n181             top = subplot_params.top\n182             wspace = subplot_params.wspace\n183             hspace = subplot_params.hspace\n184         tot_width = right - left\n185         tot_height = top - bottom\n186 \n187         # calculate accumulated heights of columns\n188         cell_h = tot_height / (nrows + hspace*(nrows-1))\n189         sep_h = hspace * cell_h\n190         norm = cell_h * nrows / sum(self._row_height_ratios)\n191         cell_heights = [r * norm for r in self._row_height_ratios]\n192         sep_heights = [0] + ([sep_h] * (nrows-1))\n193         cell_hs = np.cumsum(np.column_stack([sep_heights, cell_heights]).flat)\n194 \n195         # calculate accumulated widths of rows\n196         cell_w = tot_width / (ncols + wspace*(ncols-1))\n197         sep_w = wspace * cell_w\n198         norm = cell_w * ncols / sum(self._col_width_ratios)\n199         cell_widths = [r * norm for r in self._col_width_ratios]\n200         sep_widths = [0] + ([sep_w] * (ncols-1))\n201         cell_ws = np.cumsum(np.column_stack([sep_widths, cell_widths]).flat)\n202 \n203         fig_tops, fig_bottoms = (top - cell_hs).reshape((-1, 2)).T\n204         fig_lefts, fig_rights = (left + cell_ws).reshape((-1, 2)).T\n205         return fig_bottoms, fig_tops, fig_lefts, fig_rights\n206 \n207     @staticmethod\n208     def _check_gridspec_exists(figure, nrows, ncols):\n209         \"\"\"\n210         Check if the figure already has a gridspec with these dimensions,\n211         or create a new one\n212         \"\"\"\n213         for ax in figure.get_axes():\n214             gs = ax.get_gridspec()\n215             if gs is not None:\n216                 if hasattr(gs, 'get_topmost_subplotspec'):\n217                     # This is needed for colorbar gridspec layouts.\n218                     # This is probably OK because this whole logic tree\n219                     # is for when the user is doing simple things with the\n220                     # add_subplot command.  For complicated layouts\n221                     # like subgridspecs the proper gridspec is passed in...\n222                     gs = gs.get_topmost_subplotspec().get_gridspec()\n223                 if gs.get_geometry() == (nrows, ncols):\n224                     return gs\n225         # else gridspec not found:\n226         return GridSpec(nrows, ncols, figure=figure)\n227 \n228     def __getitem__(self, key):\n229         \"\"\"Create and return a `.SubplotSpec` instance.\"\"\"\n230         nrows, ncols = self.get_geometry()\n231 \n232         def _normalize(key, size, axis):  # Includes last index.\n233             orig_key = key\n234             if isinstance(key, slice):\n235                 start, stop, _ = key.indices(size)\n236                 if stop > start:\n237                     return start, stop - 1\n238                 raise IndexError(\"GridSpec slice would result in no space \"\n239                                  \"allocated for subplot\")\n240             else:\n241                 if key < 0:\n242                     key = key + size\n243                 if 0 <= key < size:\n244                     return key, key\n245                 elif axis is not None:\n246                     raise IndexError(f\"index {orig_key} is out of bounds for \"\n247                                      f\"axis {axis} with size {size}\")\n248                 else:  # flat index\n249                     raise IndexError(f\"index {orig_key} is out of bounds for \"\n250                                      f\"GridSpec with size {size}\")\n251 \n252         if isinstance(key, tuple):\n253             try:\n254                 k1, k2 = key\n255             except ValueError as err:\n256                 raise ValueError(\"Unrecognized subplot spec\") from err\n257             num1, num2 = np.ravel_multi_index(\n258                 [_normalize(k1, nrows, 0), _normalize(k2, ncols, 1)],\n259                 (nrows, ncols))\n260         else:  # Single key\n261             num1, num2 = _normalize(key, nrows * ncols, None)\n262 \n263         return SubplotSpec(self, num1, num2)\n264 \n265     def subplots(self, *, sharex=False, sharey=False, squeeze=True,\n266                  subplot_kw=None):\n267         \"\"\"\n268         Add all subplots specified by this `GridSpec` to its parent figure.\n269 \n270         See `.Figure.subplots` for detailed documentation.\n271         \"\"\"\n272 \n273         figure = self.figure\n274 \n275         if figure is None:\n276             raise ValueError(\"GridSpec.subplots() only works for GridSpecs \"\n277                              \"created with a parent figure\")\n278 \n279         if isinstance(sharex, bool):\n280             sharex = \"all\" if sharex else \"none\"\n281         if isinstance(sharey, bool):\n282             sharey = \"all\" if sharey else \"none\"\n283         # This check was added because it is very easy to type\n284         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n285         # In most cases, no error will ever occur, but mysterious behavior\n286         # will result because what was intended to be the subplot index is\n287         # instead treated as a bool for sharex.  This check should go away\n288         # once sharex becomes kwonly.\n289         if isinstance(sharex, Integral):\n290             _api.warn_external(\n291                 \"sharex argument to subplots() was an integer.  Did you \"\n292                 \"intend to use subplot() (without 's')?\")\n293         _api.check_in_list([\"all\", \"row\", \"col\", \"none\"],\n294                            sharex=sharex, sharey=sharey)\n295         if subplot_kw is None:\n296             subplot_kw = {}\n297         # don't mutate kwargs passed by user...\n298         subplot_kw = subplot_kw.copy()\n299 \n300         # Create array to hold all axes.\n301         axarr = np.empty((self._nrows, self._ncols), dtype=object)\n302         for row in range(self._nrows):\n303             for col in range(self._ncols):\n304                 shared_with = {\"none\": None, \"all\": axarr[0, 0],\n305                                \"row\": axarr[row, 0], \"col\": axarr[0, col]}\n306                 subplot_kw[\"sharex\"] = shared_with[sharex]\n307                 subplot_kw[\"sharey\"] = shared_with[sharey]\n308                 axarr[row, col] = figure.add_subplot(\n309                     self[row, col], **subplot_kw)\n310 \n311         # turn off redundant tick labeling\n312         if sharex in [\"col\", \"all\"]:\n313             for ax in axarr.flat:\n314                 ax._label_outer_xaxis(check_patch=True)\n315         if sharey in [\"row\", \"all\"]:\n316             for ax in axarr.flat:\n317                 ax._label_outer_yaxis(check_patch=True)\n318 \n319         if squeeze:\n320             # Discarding unneeded dimensions that equal 1.  If we only have one\n321             # subplot, just return it instead of a 1-element array.\n322             return axarr.item() if axarr.size == 1 else axarr.squeeze()\n323         else:\n324             # Returned axis array will be always 2-d, even if nrows=ncols=1.\n325             return axarr\n326 \n327 \n328 class GridSpec(GridSpecBase):\n329     \"\"\"\n330     A grid layout to place subplots within a figure.\n331 \n332     The location of the grid cells is determined in a similar way to\n333     `~.figure.SubplotParams` using *left*, *right*, *top*, *bottom*, *wspace*\n334     and *hspace*.\n335 \n336     Indexing a GridSpec instance returns a `.SubplotSpec`.\n337     \"\"\"\n338     def __init__(self, nrows, ncols, figure=None,\n339                  left=None, bottom=None, right=None, top=None,\n340                  wspace=None, hspace=None,\n341                  width_ratios=None, height_ratios=None):\n342         \"\"\"\n343         Parameters\n344         ----------\n345         nrows, ncols : int\n346             The number of rows and columns of the grid.\n347 \n348         figure : `.Figure`, optional\n349             Only used for constrained layout to create a proper layoutgrid.\n350 \n351         left, right, top, bottom : float, optional\n352             Extent of the subplots as a fraction of figure width or height.\n353             Left cannot be larger than right, and bottom cannot be larger than\n354             top. If not given, the values will be inferred from a figure or\n355             rcParams at draw time. See also `GridSpec.get_subplot_params`.\n356 \n357         wspace : float, optional\n358             The amount of width reserved for space between subplots,\n359             expressed as a fraction of the average axis width.\n360             If not given, the values will be inferred from a figure or\n361             rcParams when necessary. See also `GridSpec.get_subplot_params`.\n362 \n363         hspace : float, optional\n364             The amount of height reserved for space between subplots,\n365             expressed as a fraction of the average axis height.\n366             If not given, the values will be inferred from a figure or\n367             rcParams when necessary. See also `GridSpec.get_subplot_params`.\n368 \n369         width_ratios : array-like of length *ncols*, optional\n370             Defines the relative widths of the columns. Each column gets a\n371             relative width of ``width_ratios[i] / sum(width_ratios)``.\n372             If not given, all columns will have the same width.\n373 \n374         height_ratios : array-like of length *nrows*, optional\n375             Defines the relative heights of the rows. Each row gets a\n376             relative height of ``height_ratios[i] / sum(height_ratios)``.\n377             If not given, all rows will have the same height.\n378 \n379         \"\"\"\n380         self.left = left\n381         self.bottom = bottom\n382         self.right = right\n383         self.top = top\n384         self.wspace = wspace\n385         self.hspace = hspace\n386         self.figure = figure\n387 \n388         super().__init__(nrows, ncols,\n389                          width_ratios=width_ratios,\n390                          height_ratios=height_ratios)\n391 \n392     _AllowedKeys = [\"left\", \"bottom\", \"right\", \"top\", \"wspace\", \"hspace\"]\n393 \n394     def update(self, **kwargs):\n395         \"\"\"\n396         Update the subplot parameters of the grid.\n397 \n398         Parameters that are not explicitly given are not changed. Setting a\n399         parameter to *None* resets it to :rc:`figure.subplot.*`.\n400 \n401         Parameters\n402         ----------\n403         left, right, top, bottom : float or None, optional\n404             Extent of the subplots as a fraction of figure width or height.\n405         wspace, hspace : float, optional\n406             Spacing between the subplots as a fraction of the average subplot\n407             width / height.\n408         \"\"\"\n409         for k, v in kwargs.items():\n410             if k in self._AllowedKeys:\n411                 setattr(self, k, v)\n412             else:\n413                 raise AttributeError(f\"{k} is an unknown keyword\")\n414         for figmanager in _pylab_helpers.Gcf.figs.values():\n415             for ax in figmanager.canvas.figure.axes:\n416                 if ax.get_subplotspec() is not None:\n417                     ss = ax.get_subplotspec().get_topmost_subplotspec()\n418                     if ss.get_gridspec() == self:\n419                         ax._set_position(\n420                             ax.get_subplotspec().get_position(ax.figure))\n421 \n422     def get_subplot_params(self, figure=None):\n423         \"\"\"\n424         Return the `.SubplotParams` for the GridSpec.\n425 \n426         In order of precedence the values are taken from\n427 \n428         - non-*None* attributes of the GridSpec\n429         - the provided *figure*\n430         - :rc:`figure.subplot.*`\n431         \"\"\"\n432         if figure is None:\n433             kw = {k: mpl.rcParams[\"figure.subplot.\"+k]\n434                   for k in self._AllowedKeys}\n435             subplotpars = mpl.figure.SubplotParams(**kw)\n436         else:\n437             subplotpars = copy.copy(figure.subplotpars)\n438 \n439         subplotpars.update(**{k: getattr(self, k) for k in self._AllowedKeys})\n440 \n441         return subplotpars\n442 \n443     def locally_modified_subplot_params(self):\n444         \"\"\"\n445         Return a list of the names of the subplot parameters explicitly set\n446         in the GridSpec.\n447 \n448         This is a subset of the attributes of `.SubplotParams`.\n449         \"\"\"\n450         return [k for k in self._AllowedKeys if getattr(self, k)]\n451 \n452     def tight_layout(self, figure, renderer=None,\n453                      pad=1.08, h_pad=None, w_pad=None, rect=None):\n454         \"\"\"\n455         Adjust subplot parameters to give specified padding.\n456 \n457         Parameters\n458         ----------\n459         pad : float\n460             Padding between the figure edge and the edges of subplots, as a\n461             fraction of the font-size.\n462         h_pad, w_pad : float, optional\n463             Padding (height/width) between edges of adjacent subplots.\n464             Defaults to *pad*.\n465         rect : tuple (left, bottom, right, top), default: None\n466             (left, bottom, right, top) rectangle in normalized figure\n467             coordinates that the whole subplots area (including labels) will\n468             fit into. Default (None) is the whole figure.\n469         \"\"\"\n470         if renderer is None:\n471             renderer = figure._get_renderer()\n472         kwargs = _tight_layout.get_tight_layout_figure(\n473             figure, figure.axes,\n474             _tight_layout.get_subplotspec_list(figure.axes, grid_spec=self),\n475             renderer, pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n476         if kwargs:\n477             self.update(**kwargs)\n478 \n479 \n480 class GridSpecFromSubplotSpec(GridSpecBase):\n481     \"\"\"\n482     GridSpec whose subplot layout parameters are inherited from the\n483     location specified by a given SubplotSpec.\n484     \"\"\"\n485     def __init__(self, nrows, ncols,\n486                  subplot_spec,\n487                  wspace=None, hspace=None,\n488                  height_ratios=None, width_ratios=None):\n489         \"\"\"\n490         Parameters\n491         ----------\n492         nrows, ncols : int\n493             Number of rows and number of columns of the grid.\n494         subplot_spec : SubplotSpec\n495             Spec from which the layout parameters are inherited.\n496         wspace, hspace : float, optional\n497             See `GridSpec` for more details. If not specified default values\n498             (from the figure or rcParams) are used.\n499         height_ratios : array-like of length *nrows*, optional\n500             See `GridSpecBase` for details.\n501         width_ratios : array-like of length *ncols*, optional\n502             See `GridSpecBase` for details.\n503         \"\"\"\n504         self._wspace = wspace\n505         self._hspace = hspace\n506         self._subplot_spec = subplot_spec\n507         self.figure = self._subplot_spec.get_gridspec().figure\n508         super().__init__(nrows, ncols,\n509                          width_ratios=width_ratios,\n510                          height_ratios=height_ratios)\n511 \n512     def get_subplot_params(self, figure=None):\n513         \"\"\"Return a dictionary of subplot layout parameters.\"\"\"\n514         hspace = (self._hspace if self._hspace is not None\n515                   else figure.subplotpars.hspace if figure is not None\n516                   else mpl.rcParams[\"figure.subplot.hspace\"])\n517         wspace = (self._wspace if self._wspace is not None\n518                   else figure.subplotpars.wspace if figure is not None\n519                   else mpl.rcParams[\"figure.subplot.wspace\"])\n520 \n521         figbox = self._subplot_spec.get_position(figure)\n522         left, bottom, right, top = figbox.extents\n523 \n524         return mpl.figure.SubplotParams(left=left, right=right,\n525                                         bottom=bottom, top=top,\n526                                         wspace=wspace, hspace=hspace)\n527 \n528     def get_topmost_subplotspec(self):\n529         \"\"\"\n530         Return the topmost `.SubplotSpec` instance associated with the subplot.\n531         \"\"\"\n532         return self._subplot_spec.get_topmost_subplotspec()\n533 \n534 \n535 class SubplotSpec:\n536     \"\"\"\n537     The location of a subplot in a `GridSpec`.\n538 \n539     .. note::\n540 \n541         Likely, you'll never instantiate a `SubplotSpec` yourself. Instead you\n542         will typically obtain one from a `GridSpec` using item-access.\n543 \n544     Parameters\n545     ----------\n546     gridspec : `~matplotlib.gridspec.GridSpec`\n547         The GridSpec, which the subplot is referencing.\n548     num1, num2 : int\n549         The subplot will occupy the num1-th cell of the given\n550         gridspec.  If num2 is provided, the subplot will span between\n551         num1-th cell and num2-th cell *inclusive*.\n552 \n553         The index starts from 0.\n554     \"\"\"\n555     def __init__(self, gridspec, num1, num2=None):\n556         self._gridspec = gridspec\n557         self.num1 = num1\n558         self.num2 = num2\n559 \n560     def __repr__(self):\n561         return (f\"{self.get_gridspec()}[\"\n562                 f\"{self.rowspan.start}:{self.rowspan.stop}, \"\n563                 f\"{self.colspan.start}:{self.colspan.stop}]\")\n564 \n565     @staticmethod\n566     def _from_subplot_args(figure, args):\n567         \"\"\"\n568         Construct a `.SubplotSpec` from a parent `.Figure` and either\n569 \n570         - a `.SubplotSpec` -- returned as is;\n571         - one or three numbers -- a MATLAB-style subplot specifier.\n572         \"\"\"\n573         if len(args) == 1:\n574             arg, = args\n575             if isinstance(arg, SubplotSpec):\n576                 return arg\n577             elif not isinstance(arg, Integral):\n578                 raise ValueError(\n579                     f\"Single argument to subplot must be a three-digit \"\n580                     f\"integer, not {arg!r}\")\n581             try:\n582                 rows, cols, num = map(int, str(arg))\n583             except ValueError:\n584                 raise ValueError(\n585                     f\"Single argument to subplot must be a three-digit \"\n586                     f\"integer, not {arg!r}\") from None\n587         elif len(args) == 3:\n588             rows, cols, num = args\n589         else:\n590             raise TypeError(f\"subplot() takes 1 or 3 positional arguments but \"\n591                             f\"{len(args)} were given\")\n592 \n593         gs = GridSpec._check_gridspec_exists(figure, rows, cols)\n594         if gs is None:\n595             gs = GridSpec(rows, cols, figure=figure)\n596         if isinstance(num, tuple) and len(num) == 2:\n597             if not all(isinstance(n, Integral) for n in num):\n598                 raise ValueError(\n599                     f\"Subplot specifier tuple must contain integers, not {num}\"\n600                 )\n601             i, j = num\n602         else:\n603             if not isinstance(num, Integral) or num < 1 or num > rows*cols:\n604                 raise ValueError(\n605                     f\"num must be 1 <= num <= {rows*cols}, not {num!r}\")\n606             i = j = num\n607         return gs[i-1:j]\n608 \n609     # num2 is a property only to handle the case where it is None and someone\n610     # mutates num1.\n611 \n612     @property\n613     def num2(self):\n614         return self.num1 if self._num2 is None else self._num2\n615 \n616     @num2.setter\n617     def num2(self, value):\n618         self._num2 = value\n619 \n620     def get_gridspec(self):\n621         return self._gridspec\n622 \n623     def get_geometry(self):\n624         \"\"\"\n625         Return the subplot geometry as tuple ``(n_rows, n_cols, start, stop)``.\n626 \n627         The indices *start* and *stop* define the range of the subplot within\n628         the `GridSpec`. *stop* is inclusive (i.e. for a single cell\n629         ``start == stop``).\n630         \"\"\"\n631         rows, cols = self.get_gridspec().get_geometry()\n632         return rows, cols, self.num1, self.num2\n633 \n634     @property\n635     def rowspan(self):\n636         \"\"\"The rows spanned by this subplot, as a `range` object.\"\"\"\n637         ncols = self.get_gridspec().ncols\n638         return range(self.num1 // ncols, self.num2 // ncols + 1)\n639 \n640     @property\n641     def colspan(self):\n642         \"\"\"The columns spanned by this subplot, as a `range` object.\"\"\"\n643         ncols = self.get_gridspec().ncols\n644         # We explicitly support num2 referring to a column on num1's *left*, so\n645         # we must sort the column indices here so that the range makes sense.\n646         c1, c2 = sorted([self.num1 % ncols, self.num2 % ncols])\n647         return range(c1, c2 + 1)\n648 \n649     def is_first_row(self):\n650         return self.rowspan.start == 0\n651 \n652     def is_last_row(self):\n653         return self.rowspan.stop == self.get_gridspec().nrows\n654 \n655     def is_first_col(self):\n656         return self.colspan.start == 0\n657 \n658     def is_last_col(self):\n659         return self.colspan.stop == self.get_gridspec().ncols\n660 \n661     def get_position(self, figure):\n662         \"\"\"\n663         Update the subplot position from ``figure.subplotpars``.\n664         \"\"\"\n665         gridspec = self.get_gridspec()\n666         nrows, ncols = gridspec.get_geometry()\n667         rows, cols = np.unravel_index([self.num1, self.num2], (nrows, ncols))\n668         fig_bottoms, fig_tops, fig_lefts, fig_rights = \\\n669             gridspec.get_grid_positions(figure)\n670 \n671         fig_bottom = fig_bottoms[rows].min()\n672         fig_top = fig_tops[rows].max()\n673         fig_left = fig_lefts[cols].min()\n674         fig_right = fig_rights[cols].max()\n675         return Bbox.from_extents(fig_left, fig_bottom, fig_right, fig_top)\n676 \n677     def get_topmost_subplotspec(self):\n678         \"\"\"\n679         Return the topmost `SubplotSpec` instance associated with the subplot.\n680         \"\"\"\n681         gridspec = self.get_gridspec()\n682         if hasattr(gridspec, \"get_topmost_subplotspec\"):\n683             return gridspec.get_topmost_subplotspec()\n684         else:\n685             return self\n686 \n687     def __eq__(self, other):\n688         \"\"\"\n689         Two SubplotSpecs are considered equal if they refer to the same\n690         position(s) in the same `GridSpec`.\n691         \"\"\"\n692         # other may not even have the attributes we are checking.\n693         return ((self._gridspec, self.num1, self.num2)\n694                 == (getattr(other, \"_gridspec\", object()),\n695                     getattr(other, \"num1\", object()),\n696                     getattr(other, \"num2\", object())))\n697 \n698     def __hash__(self):\n699         return hash((self._gridspec, self.num1, self.num2))\n700 \n701     def subgridspec(self, nrows, ncols, **kwargs):\n702         \"\"\"\n703         Create a GridSpec within this subplot.\n704 \n705         The created `.GridSpecFromSubplotSpec` will have this `SubplotSpec` as\n706         a parent.\n707 \n708         Parameters\n709         ----------\n710         nrows : int\n711             Number of rows in grid.\n712 \n713         ncols : int\n714             Number or columns in grid.\n715 \n716         Returns\n717         -------\n718         `.GridSpecFromSubplotSpec`\n719 \n720         Other Parameters\n721         ----------------\n722         **kwargs\n723             All other parameters are passed to `.GridSpecFromSubplotSpec`.\n724 \n725         See Also\n726         --------\n727         matplotlib.pyplot.subplots\n728 \n729         Examples\n730         --------\n731         Adding three subplots in the space occupied by a single subplot::\n732 \n733             fig = plt.figure()\n734             gs0 = fig.add_gridspec(3, 1)\n735             ax1 = fig.add_subplot(gs0[0])\n736             ax2 = fig.add_subplot(gs0[1])\n737             gssub = gs0[2].subgridspec(1, 3)\n738             for i in range(3):\n739                 fig.add_subplot(gssub[0, i])\n740         \"\"\"\n741         return GridSpecFromSubplotSpec(nrows, ncols, self, **kwargs)\n742 \n[end of lib/matplotlib/gridspec.py]\n</code>\nI need you to solve this issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the following format.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\n\n\n\nAssistant:"}]